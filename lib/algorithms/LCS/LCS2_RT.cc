/******************************************************************************
 * @file LCS2_RT.cc
 * @author Steinkopp:Felix
 * @version 0.2
 * @brief Implementation of an algorithm for LCS2_Classic with RangeTrees
 *****************************************************************************/

#include "algorithms/LCS/LCS2_RT.h"

#include <sstream>
#include <utility>

#include "algorithms/AlgoFactory.h"
#include "algorithms/LLCS/LLCS2_Algorithm.h"
#include "algorithms/LLCS/LLCS2_SR_MQ.h"
#include "algorithms/LLCS/LLCS2_SR_RMQ.h"
#include "algorithms/LLCS/LLCS2_SL_R.h"
#include "algorithms/solutions/EmptySolution.h"
#include "problems/AdamsonEtAl/LCS2_SIGMA_L.h"

namespace lcs_solver::algorithms::lcs {

/**
 * Constructor for LCS2_RT
 * @param spv The vector of shared points to the constant strings of a problem
 * @param map map<std::string, share_ptr<BaseConstraint> with the constraints
 * @param type AlgoType the type of the algorithm to use to generate the dynamic
 *  programming table. Should be a LLCS2 Algorithm.
 * @note The algorithm to use is generated by AlgoFactory::create
 */
LCS2_RT::LCS2_RT(const StrPtrVector &spv, const ConstraintMap &map, const AlgoType type)
    : BaseAlgorithm(AlgoCategory::LLCS, AlgoType::LCS2_RT, spv, map),
      algo_(std::dynamic_pointer_cast<llcs::LLCS2_Algorithm>(
          std::shared_ptr<BaseAlgorithm>(
              AlgoFactory::Create(type, spv, map).release()))) {
  if (algo_) {
    algo_->setTracking(true);
  }
}

/**
 * isValid
 * @return true, iff algo is valid, inherits from LLCS_Algorithm
 */
bool LCS2_RT::isValid() const {
  if (algo_ == nullptr) {
    return false;// *algo did not inherit from llcs::LLCS2_Algorithm
  }
  bool const svvIsOfLengthTwo = algo_->getStrPtrVec().size() == 2;
  bool const algoIsValid = algo_->isValid();
  return algoIsValid && svvIsOfLengthTwo;
}

/**
 * Getter for the algorithms pseudocode
 * @return std::string_view of the description string
 */
std::string_view LCS2_RT::getDescription() const {
  static constexpr std::string_view msg = R"DESC(Pseudocode: Reconstruction of LCS with Rangetree
> Initialization:
>   let tree = array of RangeTrees[1..llcs] such that tree_[i] contains a point q = (x,y) if LLCS(s1[1:x],s2[1:y]) == i and
>              q is extendable to some point p in tree_[i-1] (for i>1). The points are initially tracked during a dp algo
>   let current = array of points to store an embedding
>   let result = array[1..llcs] to store query results
>   let it = array[1..llcs] of iterators for result
>   let end = array[1..llcs] of end markers
>   let level = llcs (determines in which tree to look for points)
>
> Construction:
>   Initialize first valid position:
>     r1 = (1, length of first sequence)
>     r2 = (1, length of second sequence)
>     for level = llcs down to 1:
>       result[level] = tree[level].query(r1, r2)
>       it[level] = result[level].begin()
>       if it[level] == result[level].end():
>         return iterator as ended // there is not a valid lcs
>       current.push_back(it[level])
>       if level > 1:
>         update r1, r2 using getPrevRange(current point)
>   set level to 1
>
> Advance:
>   if iterator ended return
>   while level <= llcs:
>     if it[level] reached end:
>       increment level
>     else:
>       increment it[level]
>       if new point found:
>         update current solution
>         for each level from current down to 1:
>           update ranges
>           query range trees
>           update iterators and solution
>         break
>   if no new point found:
>     mark iterator as ended)DESC";
  return msg;
}

/**
 * DebugString
 * @return  std::string containing the type and DebugSting of algo
 */
std::string LCS2_RT::DebugString() const {
  std::ostringstream oss;
  oss << "type: " << static_cast<int>(type) << "\n";
  oss << "algo->DebugString()\n" << algo_->DebugString() << "\n";
  return oss.str();
}

/**
 * @brief Executes algo and creates an appropriate LCS RangeTree Solution
 * @return std::unique_ptr<BaseSolution> A unique pointer to a solution object:
 * - `EmptySolution` if the object is not valid or zero strings are provided
 * - `Points` equivalent to to s[1] if only one valid string is provided
 * - `LCS_STD_FL::StackSolution` to generate all possible LCS Sequences (
 */
std::unique_ptr<BaseSolution> LCS2_RT::query() {
  // reset(ResetLevel::Full);
  if (s.empty() || !isValid()) {
    return std::make_unique<solutions::EmptySolution>();
  }
  if (s.size() == 1) {
    std::vector<std::vector<size_t>> mat(s[0].size() - 1);
    for (size_t i = 0; i < mat.size(); i++) { mat[i].push_back(i); }// [0,1,..,|s0|-1]^T
    return std::make_unique<solutions::Points>(getStrPtrVec(), mat);
  }
  if (algo_->getState() != BaseAlgorithm::State::Preprocessed)
    algo_->doPreprocessing();
  return std::make_unique<RangeTreeSolution>(algo_);
}

/*******************************************************************************
 * @brief Executes the llcs algorithm
 * @see LLCS_STD_FL::doPreprocessing
 ******************************************************************************/
void LCS2_RT::doPreprocessing() {
  algo_->doPreprocessing();
  setState(State::Preprocessed);
}

/*******************************************************************************
 * Resets the algo that is used to get the lcs points in the RangeTreeSolution
 * @param lvl BaseAlgorithm::ResetLevel to be applied
 ******************************************************************************/
void LCS2_RT::reset(const ResetLevel lvl) {
  algo_->reset(lvl);
  setState(algo_->getState());
}

/**
 * RangeTreeSolution - Constructor
 * @param ptr LLCS2_Algorithm for getting the necessary reconstruction data
 */
LCS2_RT::RangeTreeSolution::RangeTreeSolution(const std::shared_ptr<llcs::LLCS2_Algorithm> &ptr)
    : algo_(ptr) {}

/**
 * RangeTreeSolution::begin
 * @return Iterator for returning all possible LCS Subsequences
 */
LCS2_RT::RangeTreeSolution::AnyIterator LCS2_RT::RangeTreeSolution::begin() const {
  return AnyIterator(Iterator(algo_, false));
}

/**
 * RangeTreeSolution::end
 * @return Iterator for returning all possible LCS Subsequences
 */
LCS2_RT::RangeTreeSolution::AnyIterator LCS2_RT::RangeTreeSolution::end() const {
  return AnyIterator(Iterator(algo_, true));
}

/**
 * RangeTreeSolution::clone
 * @return cloned RangeTreeSolution (can be created by calling the constructor)
 */
BaseSolution *LCS2_RT::RangeTreeSolution::clone() const {
  return new RangeTreeSolution(algo_);
}

LCS2_RT::RangeTreeSolution::Iterator::Iterator()
    : algo_(nullptr),
      llcs(0),
      aligned_(true),
      tree_(),
      current_(nullptr),
      lvl(0) {
  is_end = true;
}
/**
 * Constructor for Iterator
 * @param algo weak_ptr<LLCS2_Algorithm> to access `LLCS2_Algorithm::isMatched`
 *  and `LLCS2_Algorithm::isExtensible`. Also used to generate the range trees
 * @param end Whether the iterator has finished processing
 */
LCS2_RT::RangeTreeSolution::Iterator::Iterator(const std::weak_ptr<llcs::LLCS2_Algorithm> &algo, bool end)
    : algo_(std::move(algo.lock())),
      llcs(llcs::LLCS2_Algorithm::lenKPtM(algo_->getKeyPairs())),
      aligned_(*(algo_->getStrPtrVec().at(0)) == algo_->getStringViewVec().at(0)),
      tree_(genTrees(algo_)),
      current_(std::make_unique<solutions::Points>(algo_->getStrPtrVec(), false)) {
  using llcs::LLCS2_SR_RMQ;
  using llcs::LLCS2_SR_MQ;
  using llcs::LLCS2_SL_R;
  // auto test = std::make_unique<LLCS2_SL_R<LLCS2_SR_MQ>>(algo_->getStrPtrVec(), algo_->getConstraintMap());
  if (dynamic_cast<LLCS2_SL_R<LLCS2_SR_MQ>*>(algo_.get()))
    do_reversing_ = true;
  if (dynamic_cast<LLCS2_SL_R<LLCS2_SR_RMQ>*>(algo_.get()))
    do_reversing_ = true;
  if (end || !algo_ || llcs == 0) {
    setEnd();
    return;
  }
  result_.resize(llcs + 1);// result_ and tree_ have dummy values at pos 0
  it_.resize(llcs + 1);
  end_.resize(llcs + 1);
  current_->resize(llcs);
  current = current_.get();// Set current in the BaseIterator Interface

  // Advance to the first valid position
  Pair r1 = {1, algo_->getStringViewVec().at(0).size()};
  Pair r2 = {1, algo_->getStringViewVec().at(1).size()};
  for (lvl = llcs; lvl >= 1; --lvl) {
    result_[lvl] = tree_[lvl]->query(r1, r2);
    it_[lvl] = result_[lvl].begin();
    end_[lvl] = result_[lvl].end();
    if (it_[lvl] == end_[lvl]) {
      setEnd();
      return;
    }
    current_->at(lvl,true) = {(*it_[lvl]).first, (*it_[lvl]).second};
    // current_->push_back(*it_[lvl]);
    if (lvl > 1) {
      Pair head = *it_[lvl];
      const auto ranges = algo_->getPrevRange(head, lvl);
      r1 = ranges.first;
      r2 = ranges.second;
    }
  }//l
  lvl = 1;
  reversePost();
}

void LCS2_RT::RangeTreeSolution::Iterator::advance() {
  reversePre();
  if (is_end) return;

  bool foundNewPoint = false;
  while (!foundNewPoint && lvl <= llcs) {
    if (it_[lvl] == end_[lvl]) {
      ++lvl;
    } else {
      ++(it_[lvl]);
      foundNewPoint = (it_[lvl] != end_[lvl]);
    }
  }
  if (foundNewPoint) {
    current_->at(lvl,true) = {(*it_[lvl]).first, (*it_[lvl]).second} ;
    // current_->mod(lvl, *it_[lvl], true);
    while (lvl > 1) {
      auto lastModdedPos = current_->at(lvl, true);
      Pair point = std::make_pair(lastModdedPos[0], lastModdedPos[1]);
      const auto r = algo_->getPrevRange(point, lvl);
      result_[lvl - 1] = tree_[lvl - 1]->query(r.first, r.second);
      it_[lvl - 1] = result_[lvl - 1].begin();
      end_[lvl - 1] = result_[lvl - 1].end();
      assert(it_[lvl - 1] != end_[lvl - 1]);
      // current_->mod(lvl, *it_[lvl], true);
      current_->at(lvl - 1,true) = {(*it_[lvl-1]).first, (*it_[lvl-1]).second} ;
      // ++it_[lvl-1];
      --lvl;
    }
  } else {
    setEnd();
  }
  reversePost();
}

std::unique_ptr<solutions::BaseIterator> LCS2_RT::RangeTreeSolution::Iterator::clone() const {
  auto ptr = std::make_unique<Iterator>();
  ptr->algo_ = this->algo_;
  ptr->llcs = llcs;
  ptr->tree_ = tree_;
  ptr->result_ = result_;
  ptr->it_ = it_;
  ptr->end_ = end_;
  const auto p = static_cast<solutions::Points *>(current_->clone());
  ptr->current_ = std::unique_ptr<solutions::Points>(p);
  ptr->lvl = lvl;
  return std::move(ptr);
}

/**
 * genTrees (Helper function)
 * @param ptr shared_ptr<LLCS2_Algorithm> to access tracked keyPairs
 * @return list[x] is the RangeTree2D that contains all points u=(u1,u2) with
 *  1) llcs(s1[1:u1], s2[1:u2]) == x
 *  2) if x > 1, then it also exists a point l(l1,l2) in list[x-1]
 * @see LLCS2_Algorithm::getKeyPairs and the use of LLCS2_Algorithm::track
 */
std::vector<std::shared_ptr<LCS2_RT::RangeTreeSolution::Iterator::RangeTree2D>>
LCS2_RT::RangeTreeSolution::Iterator::genTrees(
    const std::shared_ptr<llcs::LLCS2_Algorithm> &ptr) const {
  if (ptr->getState() != State::Preprocessed)
    ptr->doPreprocessing();
  auto keyPairsCollections = ptr->getKeyPairs();
  std::vector<std::shared_ptr<RangeTree2D>> vec;// Shall be one based
  vec.reserve(llcs + 1);                        // llcs is already set by the constructor and vec shall be one based
  vec.emplace_back(std::shared_ptr<RangeTree2D>(nullptr));
  for (uint i = 1; i <= llcs; ++i) {
    if (keyPairsCollections[i].empty()) {
      vec.emplace_back(std::shared_ptr<RangeTree2D>(nullptr));
    } else {
      vec.emplace_back(std::make_shared<RangeTree2D>(keyPairsCollections[i]));
    }
  }
  return vec;
}

void LCS2_RT::RangeTreeSolution::Iterator::setEnd() {
  if (current_ == nullptr) {
    current_ = std::make_unique<solutions::Points>();
    current = current_.get();
  } else {
    current_->clear();
    current = current_.get();
  }
  is_end = true;
}

void LCS2_RT::RangeTreeSolution::Iterator::reversePre() {
  if (!aligned_) {
    for (auto& vec : current_->data()) {
      std::swap(vec[0],  vec[1]);
    }
  }
  if (do_reversing_) {
    current_->reverse();
  }
}

void LCS2_RT::RangeTreeSolution::Iterator::reversePost() {
  if (!aligned_) {
    for (auto& vec : current_->data()) {
      std::swap(vec[0],  vec[1]);
    }
  }
  if (do_reversing_) {
    current_->reverse();
  }
}

const BaseAlgorithm * LCS2_RT::getBase() const {
  return algo_.get();
}

}// namespace lcs_solver::algorithms::lcs